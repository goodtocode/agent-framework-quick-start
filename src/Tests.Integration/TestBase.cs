using Goodtocode.AgentFramework.Core.Application.Abstractions;
using Goodtocode.AgentFramework.Core.Application.Common.Exceptions;
using Goodtocode.AgentFramework.Core.Domain.Auth;
using Goodtocode.AgentFramework.Infrastructure.AgentFramework.Options;
using Goodtocode.AgentFramework.Infrastructure.SqlServer.Persistence;
using Goodtocode.AgentFramework.Tests.Integration.Agent;
using Microsoft.Agents.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace Goodtocode.AgentFramework.Tests.Integration;

public abstract class TestBase : IDisposable
{
    public enum CommandResponseType
    {
        Successful,
        BadRequest,
        NotFound,
        Conflict,
        Error
    }

    internal string def = string.Empty;
    internal IDictionary<string, string[]> commandErrors = new ConcurrentDictionary<string, string[]>();
    internal Exception? exception;
    internal CommandResponseType responseType;
    internal ValidationResult validationResponse = new();
    internal AgentFrameworkContext context;
    internal IConfiguration configuration;
    internal MockAIAgent agent = new();
    internal OpenAIOptions optionsOpenAi = new();
    internal UserContext userContext = UserContext.Create(firstName: "John", lastName: "Doe", email: "john.doe@goodtocode.com", 
                                                    ownerId: Guid.NewGuid(), tenantId: Guid.NewGuid(), roles: ["Admin"]);

    private readonly ICurrentUserContext? _currentUserContext;

    public TestBase()
    {
        _currentUserContext = new MockCurrentUserContext(userContext);

        context = new AgentFrameworkContext(
            new DbContextOptionsBuilder<AgentFrameworkContext>()
                .UseInMemoryDatabase(Guid.NewGuid().ToString()).Options,
            _currentUserContext
        );

        var executingType = Assembly.GetExecutingAssembly().GetTypes()
            .FirstOrDefault(x => x.Name == "AutoGeneratedProgram") ?? typeof(TestBase);
        configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.test.json", optional: true, reloadOnChange: true)
            .AddUserSecrets(executingType.Assembly, optional: true)
            .AddEnvironmentVariables()
            .Build();

        var services = new ServiceCollection();
        services.AddDbContext<AgentFrameworkContext>(options => options.UseInMemoryDatabase(Guid.NewGuid().ToString()));
        services.AddScoped<IAgentFrameworkContext, AgentFrameworkContext>();
        services.AddScoped<AIAgent, MockAIAgent>();
        services.AddScoped<MockAIAgent>();
        var provider = services.BuildServiceProvider();
        agent = provider.GetRequiredService<MockAIAgent>();
        configuration.GetSection(nameof(OpenAI)).Bind(optionsOpenAi);
    }

    internal CommandResponseType HandleAssignResponseType
        (Exception e)
    {
        exception = e;
        switch (e)
        {
            case CustomValidationException validationException:
                commandErrors = validationException.Errors;
                responseType = CommandResponseType.BadRequest;
                break;
            case CustomNotFoundException:
                responseType = CommandResponseType.NotFound;
                break;
            case CustomConflictException:
                responseType = CommandResponseType.Conflict;
                break;
            default:
                responseType = CommandResponseType.Error;
                break;
        }

        return responseType;
    }

    internal void HandleHasResponseType(string response)
    {
        switch (response)
        {
            case "Success":
                using (new AssertionScope())
                {
                    responseType.ShouldBe(CommandResponseType.Successful);
                    exception.ShouldBeNull($"An exception was thrown: {exception?.Message}. Inner exception: {exception?.InnerException?.Message}");
                }
                break;
            case "BadRequest":
                responseType.ShouldBe(CommandResponseType.BadRequest);
                break;
            case "NotFound":
                responseType.ShouldBe(CommandResponseType.NotFound);
                break;
        }
    }

    internal void HandleExpectedValidationErrorsAssertions(string expectedErrors)
    {
        var def = this.def;

        if (string.IsNullOrWhiteSpace(expectedErrors)) return;

        var expectedErrorsCollection = expectedErrors.Split(",");

        foreach (var field in expectedErrorsCollection)
        {
            var hasCommandValidatorErrors = validationResponse.Errors.Any(x => x.PropertyName == field.Trim());
            var hasCommandErrors = commandErrors.Any(x => x.Key == field.Trim());
            var hasErrorMatch = hasCommandErrors || hasCommandValidatorErrors;
            hasErrorMatch.ShouldBeTrue();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            context?.Dispose();
        }
    }

    private class MockCurrentUserContext(UserContext userContext) : ICurrentUserContext
    {
        private readonly UserContext _userContext = userContext;

        public Guid OwnerId => _userContext.OwnerId;
        public Guid TenantId => _userContext.TenantId;
    }
}